<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Three.js Tetrahedral Discretization with Normals</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
<script>


    // Step 1: Create a scene, camera, and renderer
    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    var renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Step 2: Define the vertices of the cube
    var vertices = [
        new THREE.Vector3(0, 0, 0),
        new THREE.Vector3(1, 0, 0),
        new THREE.Vector3(1, 1, 0),
        new THREE.Vector3(0, 1, 0),
        new THREE.Vector3(0, 0, 1),
        new THREE.Vector3(1, 0, 1),
        new THREE.Vector3(1, 1, 1),
        new THREE.Vector3(0, 1, 1)
    ];

    // Step 3: Define the indices for the vertices of each tetrahedron
    var tetrahedraIndices = [
        [0, 1, 3, 4],  // Tetrahedron 1
        [1, 2, 3, 6],  // Tetrahedron 2
        [1, 3, 4, 6],  // Tetrahedron 3
        [3, 4, 6, 7],  // Tetrahedron 4
        [1, 4, 5, 6]   // Tetrahedron 5
    ];

    // Function to create tetrahedron geometry from indices
    function createTetrahedronGeometry(v0, v1, v2, v3) {
        var geometry = new THREE.BufferGeometry();
        var vertices = new Float32Array([
            v0.x, v0.y, v0.z,
            v1.x, v1.y, v1.z,
            v2.x, v2.y, v2.z,
            v0.x, v0.y, v0.z,
            v2.x, v2.y, v2.z,
            v3.x, v3.y, v3.z,
            v0.x, v0.y, v0.z,
            v3.x, v3.y, v3.z,
            v1.x, v1.y, v1.z,
            v1.x, v1.y, v1.z,
            v3.x, v3.y, v3.z,
            v2.x, v2.y, v2.z,
        ]);
        geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
        geometry.computeVertexNormals();
        return geometry;
    }

    // Function to create and add an arrow helper for a face normal
    function addFaceNormalArrow(faceCenter, normal) {
        var arrowHelper = new THREE.ArrowHelper(normal.clone().normalize(), faceCenter, 0.2, 0xff0000);
        scene.add(arrowHelper);
    }

    // Function to compute the face normal
    function computeFaceNormal(v0, v1, v2) {
        var edge1 = new THREE.Vector3().subVectors(v1, v0);
        var edge2 = new THREE.Vector3().subVectors(v2, v0);
        var normal = new THREE.Vector3().crossVectors(edge1, edge2).normalize();
        return normal;
    }

    // Function to compute the face center
    function computeFaceCenter(v0, v1, v2) {
        return new THREE.Vector3(
            (v0.x + v1.x + v2.x) / 3,
            (v0.y + v1.y + v2.y) / 3,
            (v0.z + v1.z + v2.z) / 3
        );
    }

    // Step 4: Create tetrahedra and add to the scene
    var material = new THREE.MeshNormalMaterial({ wireframe: true });
    tetrahedraIndices.forEach(indices => {
        var [i0, i1, i2, i3] = indices;
        var v0 = vertices[i0];
        var v1 = vertices[i1];
        var v2 = vertices[i2];
        var v3 = vertices[i3];

        var geometry = createTetrahedronGeometry(v0, v1, v2, v3);
        var tetrahedronMesh = new THREE.Mesh(geometry, material);
        scene.add(tetrahedronMesh);

        // Compute and add arrows for face normals
        var faces = [
            [v0, v1, v2],
            [v0, v2, v3],
            [v0, v3, v1],
            [v1, v3, v2]
        ];

        faces.forEach(face => {
            var [fv0, fv1, fv2] = face;
            var normal = computeFaceNormal(fv0, fv1, fv2);
            var faceCenter = computeFaceCenter(fv0, fv1, fv2);
            addFaceNormalArrow(faceCenter, normal);
        });
    });

    // Setting up the camera position
    camera.position.z = 3;

    // Basic render loop
    function animate() {
        requestAnimationFrame(animate);
        scene.rotation.x += 0.01;
        scene.rotation.y += 0.01;
        renderer.render(scene, camera);
    }
    animate();
</script>
</body>
</html>
