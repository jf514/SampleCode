<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Instanced Mesh Example</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.151.3/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.151.3/examples/jsm/"
            }
        }
        </script>
</head>
<body>
    <script type="module">
        import * as THREE from 'three'

        // Create the scene and camera
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 10;

        // Create the renderer
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Function to create an InstancedMesh with specified geometry, material, and instance count
        function createInstancedMesh(geometry, material, count, scale = 1) {
            const instancedMesh = new THREE.InstancedMesh(geometry, material, count);
            const dummy = new THREE.Object3D();

            for (let i = 0; i < count; i++) {
                const x = (Math.random() - 0.5) * 10;
                const y = (Math.random() - 0.5) * 10;
                const z = (Math.random() - 0.5) * 10;
                const color = new THREE.Color(Math.random(), Math.random(), Math.random());

                dummy.position.set(x, y, z);
                dummy.scale.set(scale, scale, scale);
                dummy.updateMatrix();

                instancedMesh.setMatrixAt(i, dummy.matrix);
                instancedMesh.setColorAt(i, color);
            }

            instancedMesh.instanceMatrix.needsUpdate = true;
            instancedMesh.instanceColor.needsUpdate = true;

            return instancedMesh;
        }

        // Create materials
        const cubeMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff /*, vertexColors: true*/ });
        const sphereMaterial = new THREE.MeshBasicMaterial({ vertexColors: true });

        // Create geometries
        const cubeGeometry = new THREE.BoxGeometry(1, 1, 1);
        const sphereGeometry = new THREE.SphereGeometry(0.5, 16, 16);

        // Create InstancedMeshes
        const cubeCount = 100;
        const sphereCount = 50;

        const cubes = createInstancedMesh(cubeGeometry, cubeMaterial, cubeCount);
        const spheres = createInstancedMesh(sphereGeometry, sphereMaterial, sphereCount, 0.5);

        // Add InstancedMeshes to the scene
        scene.add(cubes);
        scene.add(spheres);

        // Retrieve and log the color and position of each instance
        function logInstanceDetails(instancedMesh, count) {
            const dummy = new THREE.Object3D();
            const color = new THREE.Color();
            const position = new THREE.Vector3();
            const quaternion = new THREE.Quaternion();
            const scale = new THREE.Vector3();

            for (let i = 0; i < count; i++) {
                instancedMesh.getMatrixAt(i, dummy.matrix);
                dummy.matrix.decompose(position, quaternion, scale);
                instancedMesh.getColorAt(i, color);

                console.log(`Instance ${i}: Position (${position.x.toFixed(2)}, ${position.y.toFixed(2)}, ${position.z.toFixed(2)}), Color ${color.getStyle()}`);
            }
        }

        // Log details for cubes and spheres
        logInstanceDetails(cubes, cubeCount);
        logInstanceDetails(spheres, sphereCount);

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            const aspect = window.innerWidth / window.innerHeight;
            camera.aspect = aspect;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
